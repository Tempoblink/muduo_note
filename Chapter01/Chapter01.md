

## 第**1**章 线程安全的对象生命期管理

用同步原语(synchronization primitives)可以保护对象内部状态，但是对象的生与死不能由对象自身拥有的mutex(互斥器)来保护。

如何避免对象析构时可能存在的race condition(竞态条件)是C++多线程编程面临的基本问题，可以借助智能指针。



不同线程间，执行对象的析构与调用对象内的成员函数可能出现多种竞态条件(race condition)：

- 对象析构时，如何得知是否有线程执行对象内成员函数。
- 如何保证调用成员函数时，对象不会被另一个线程析构？
- 调用一个对象的成员函数前，如何得知对象是否还活着？它的析构函数会不会碰巧执行到一半？



一个线程安全的class应当满足以下三个条件：

- 多个线程同时访问时，其表现出正确的行为。
- 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织(interleaving)。
- 调用端代码无须额外的同步或其他协调动作。即锁在对象内部实现。而非在使用对象前外部加锁。



mudo使用**MutexLock**与**MutexLockGuard**来实现对象内部锁：

- MutexLock封装临界区(critical section)作为对象内部成员，在Linux下是 pthread_mutex_t类型，默认是不可重入的。
- MutexLockGuard封装临界区的进入和退出，即将加锁和解锁行为封装成一个对象。这个对象一般存在栈区，因此作用域刚好等于临界区域，次对象释放时自动完成解锁。



思考：如果MutexLock对象是static，是否影响正确性/或性能？

static会导致所有同步对象会共享一把锁，运行时会同时争抢同一个锁，不会影响正确性，但会严重影响到性能。



对象构造要做到线程安全，唯一的要求是在构造期间不要泄露this指针，即

- 不要在构造函数中注册任何回调。
- 不要在构造函数中把this传给跨线程的对象。
- 即便在构造函数的最后一行也不行，因为Foo有可能是个基类，基类先于派生类构造。

二段式构造——即构造函数+initialize()，先创建对象，再把自己的指针注册给其他对象。



```c++
Foo::~Foo {
  MutexLockGuard lock(mutex_);
  //free internal state ---------> 1
};
void Foo::update() {
  MutexLockGuard lock(mutex_);
  //make use of internal state ---------> 2
}

extern Foo *x //visbale by all threads;
//thread A
delete x;
x = NULL;

//thread B
if(x) {
  x->update();
}
```

尽管线程A在销毁对象之后把指针置为了NULL，尽管线程B在调用x的 成员函数之前检查了指针x的值，但还是无法避免一种race condition：

- 线程A执行到了析构函数的(1)处，已经持有了互斥锁，即将继续往下执行。
- 线程B通过了if (x)检测，阻塞在(2)处。

本质上，对象内部锁无法做到析构安全，只有保证别的线程都访问不到这个对象时，析构才是安全的，即使用智能指针控制对象的使用。



对于要同时读写一个class的两个对象，其实还是需要避免多个非递归锁的逆序加锁问题：

为了保证始终按相同的顺序加锁，可以比较mutex对象的地址，始终保持顺序性的先加锁地址较小的mutex。



对象的关系主要有三种：

- composition(组合/复合)关系在多线程里不会遇到什么麻烦，因为对象x的生命期由其唯一的拥有者owner控 制，owner析构的时候会把x也析构掉。从形式上看，x是owner的直接 数据成员，或者scoped_ptr成员，抑或owner持有的容器的元素。
- association(关联/联系)是一种很宽泛的关系，它表示一个对 象a用到了另一个对象b，调用了后者的成员函数。从代码形式上看，a 持有b的指针(或引用)，但是b的生命期不由a单独控制。
- aggregation(聚合)关系从形式上看与association相同，除了a和b有逻 辑上的整体与部分关系。如果b是动态创建的并在整个程序结束前有可能被释放，那么就会出现析构竞态条件问题。





C++里可能出现的内存问题大致有这么几个方面：

- 缓冲区溢出(buffer overrun)。用`std::vector<char>`/`std::string`或自己编写Buffer class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不 是裸指针来修改缓冲区。
- 空悬指针/野指针。用智能指针。shared_ptr/weak_ptr
- 重复释放(double delete)。用scoped_ptr，只在对象析构的时候释放一次。
- 内存泄漏(memory leak)。用scoped_ptr，对象析构的时候自动释放内存。
- 不配对的new[]/delete。把new[]统统替换为`std::vector`/`scoped_array`。
- 内存碎片(memory fragmentation)。

`scoped_ptr`/`shared_ptr`/`weak_ptr`都是值语意，要么是栈上对象，或是其他对象的直接数据成员，或是标准库容器里的元素。不存在创建在堆区里的指针指针的用法。



`shared_ptr`对象本身的线程安全级别，但它管理的对象实体不是线程安全的：

- 一个`shared_ptr`对象实体可被多个线程同时读取;
- 两个`shared_ptr`对象实体可以被两个线程同时写入，“析构”算写操作;

因此要从多个线程读写同一个`shared_ptr`对象，那么需要加锁。

临界区非常小，用互斥锁也不会阻塞并发读。

存在函数内的local copy时，`shared_ptr`作为函数参数传递时不必复制，用reference to const作为参数类型即可。

在临界区中利用`swap()`可以保证把对象的销毁推迟到临界区之外。





**shared_ptr**技术与陷阱

- **意外延长对象的生命期**，如果不小心遗留了一个拷贝，那么对象就永世长存了。比如存在容器中的智能指针、由于bind是实参拷贝，将实参与函数绑定时。

- **函数参数**，一般使用const reference方式传递，避免拷贝开销。
- **析构动作在创建时被捕获**：
	- 虚析构不再是必需的。
	- `shared_ptr<void>`可以持有任何对象，而且能安全地释放。
	- `shared_ptr`对象可以安全地跨越模块边界，比如从DLL里返回，而不会造成从模块A分配的内存在模块B里被释放这种错误。
	- 二进制兼容性。
	- 析构动作可以定制。
- **析构所在的线程**，用一个单独的线程来专门做析构，通过一个`BlockingQueue<shared_ptr<void> >`把对象的析构都转移到那个专用线程，从而解放关键线程。即管理对象的智能指针池。

- 现成的**RAII handle**，`shared_ptr`是管理共享资源的利器，需要注意避免循环引用：owner持有指向child的`shared_ptr`，child持有指 向owner的`weak_ptr`。



